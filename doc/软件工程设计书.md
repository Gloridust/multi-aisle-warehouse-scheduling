# 面向高空立体仓库的多层货位调度优化系统 — 软件工程设计书

## 一、项目概述

### 1.1 项目背景

本系统为面向高空立体仓库场景的货位调度优化软件，定位为仓储管理系统（WMS）中的智能决策支持层。系统核心解决的问题是：给定一批入库订单，如何将商品高效地分配到仓库的各个货位上。系统支持多种分配策略的选择与对比，并通过可视化的方式直观展示分配结果。系统有基础的用户登录（默认 admin 即可，不用其他的用户管理功能），当检测到不存在 SQLite 时自动初始化。

### 1.2 技术选型

- 后端：SpringBoot + SQLite（毕设只需要本地演示，但是保留 MySQL 配置扩展接口）
- 前端：Vue3 + Element UI
- 通信：RESTful API（Axios）

### 1.3 仓库物理模型

系统建模的仓库为单巷道、单堆垛机的高空立体仓库，其物理结构抽象为一个三维坐标网格（XYZ）：

- **X 轴（列）**：堆垛机沿巷道水平移动方向，共 N 列
- **Y 轴（层）**：堆垛机垂直提升方向，共 M 层
- **Z 轴（侧）**：巷道左右两侧货架，Z=0 为左侧，Z=1 为右侧
- **货位**：每个 (x, y, z) 坐标对应一个货位，对应一个托盘位
- **入库口**：位于巷道入口处的固定坐标 (entry_x, entry_y, entry_z)
- **堆垛机**：单台，在巷道内沿 X/Y 运动并伸取左右侧货位

每个货位的容量为一个标准托盘位，一个托盘上能放多少件商品由商品规格（单件体积）和托盘最大容积共同决定。

---

## 二、数据库设计

### 2.1 仓库信息表（warehouse）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| name | varchar(100) | 仓库名称 |
| total_x | int | X 轴列数（巷道方向） |
| total_y | int | Y 轴层数（高度方向） |
| total_z | int | Z 轴侧数（左右两侧，固定为2） |
| pallet_volume | decimal | 单个托盘位最大容积（立方米） |
| horizontal_speed | decimal | 堆垛机水平速度（秒/列） |
| vertical_speed | decimal | 堆垛机垂直速度（秒/层） |
| entry_x | int | 入库口所在列（默认1） |
| entry_y | int | 入库口所在层（默认1） |
| entry_z | int | 入库口所在侧（默认0） |

### 2.2 货位表（storage_location）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| warehouse_id | bigint | 所属仓库 |
| x | int | X 坐标（列） |
| y | int | Y 坐标（层） |
| z | int | Z 坐标（侧） |
| status | tinyint | 0=空闲 1=占用 2=锁定 |
| current_sku_id | bigint | 当前存放的商品ID（空闲时为null） |
| current_qty | int | 当前存放件数 |
| used_volume | decimal | 已占用体积 |

### 2.3 商品信息表（sku）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| name | varchar(100) | 商品名称 |
| category | varchar(50) | 商品分类 |
| unit_volume | decimal | 单件体积（立方米） |
| unit_weight | decimal | 单件重量（kg） |

### 2.4 入库订单表（inbound_order）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| order_no | varchar(50) | 订单编号 |
| status | tinyint | 0=待处理 1=已分配 2=已完成 |
| strategy_type | varchar(20) | 使用的分配策略 |
| create_time | datetime | 创建时间 |

### 2.5 入库订单项表（inbound_order_item）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| order_id | bigint | 所属入库订单 |
| sku_id | bigint | 商品ID |
| quantity | int | 入库数量（件） |

### 2.6 分配结果表（allocation_result）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| order_id | bigint | 所属入库订单 |
| strategy_type | varchar(20) | 策略类型 |
| location_id | bigint | 分配到的货位ID |
| sku_id | bigint | 商品ID |
| allocated_qty | int | 分配件数 |
| allocated_volume | decimal | 占用体积 |
| access_distance | decimal | 该货位到入库口的存取距离（秒） |

### 2.7 仿真结果表（simulation_result）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| order_id | bigint | 入库订单ID |
| strategy_type | varchar(20) | 策略类型 |
| total_distance | decimal | 总存取距离（秒） |
| avg_distance | decimal | 平均存取距离（秒/次） |
| space_utilization | decimal | 空间利用率（%） |
| used_locations | int | 使用货位数 |
| compute_time | bigint | 算法耗时（ms） |

---

## 三、核心算法设计

### 3.1 距离模型

堆垛机为单台设备，水平移动与垂直提升可同时进行，因此采用切比雪夫距离（取两个方向耗时的较大值）作为货位存取时间：

```
T(x,y,z) = max( |x - entry_x| × horizontal_speed, |y - entry_y| × vertical_speed ) + side_cost(z)
```

其中 `(x, y, z)` 是目标货位坐标，`(entry_x, entry_y, entry_z)` 是入库口坐标。`side_cost(z)` 用于描述左右侧伸取时间，默认可设为常数或 0。每次入库作业堆垛机需往返一趟，总耗时为 `2 × T(x,y,z)`。

总存取距离定义为所有分配动作的单程距离之和（即堆垛机需要跑多少趟 × 每趟距离）：

```
总存取距离 = Σ (托盘数k × T(location_k))
```

注：一个货位如果需要多次运送托盘（实际本系统一个货位只放一个托盘，所以托盘数=1），则每次运送都计入距离。

### 3.2 货位容量计算

```
单货位最大件数 = floor(pallet_volume / unit_volume)
```

分配某个SKU到某个货位时，最多放满一个托盘的量，剩余的分配到下一个货位。

### 3.3 策略一：分类存储策略（CATEGORY）

**核心思想**：同类商品集中存放，一个货位只存放同一种SKU的商品。

**算法流程**：

```
输入：入库订单项列表 items[], 空闲货位列表 locations[]（按货位ID排序）
输出：分配结果列表

1. 将 items 按商品分类（category）分组
2. 维护一个货位指针 ptr = 0
3. 对每个分类组：
   3.1 对组内每个订单项 item：
       remaining = item.quantity
       3.2 while remaining > 0:
           loc = locations[ptr]
           capacity = floor(pallet_volume / item.sku.unit_volume)
           allocate_qty = min(remaining, capacity)
           记录分配：loc → item.sku, allocate_qty
           remaining -= allocate_qty
           ptr++（移动到下一个空货位）
4. 返回分配结果
```

**特点**：逻辑简单，同类商品相邻存放便于管理，但不考虑距离优化。

### 3.4 策略二：就近原则策略（NEAREST）

**核心思想**：优先使用离入库口最近的货位，不区分商品分类。

**算法流程**：

```
输入：入库订单项列表 items[], 空闲货位列表 locations[]
输出：分配结果列表

1. 将 locations 按到入库口的距离 T(loc) 升序排序
2. 维护一个货位指针 ptr = 0
3. 对每个订单项 item（按顺序遍历，不分组）：
   remaining = item.quantity
   3.1 while remaining > 0:
       loc = locations[ptr]
       capacity = floor(pallet_volume / item.sku.unit_volume)
       allocate_qty = min(remaining, capacity)
       记录分配：loc → item.sku, allocate_qty
       remaining -= allocate_qty
       ptr++
4. 返回分配结果
```

**特点**：总存取距离较短，但可能导致不同SKU散乱分布，管理不便。

### 3.5 策略三：遗传算法优化策略（GENETIC）

**核心思想**：以最小化总存取距离为优化目标，使用遗传算法搜索近似最优的货位分配方案。

#### 3.5.1 编码方式

将分配问题转化为一个排列优化问题。假设本次入库共需要 K 个货位（由商品总量和托盘容量计算得出），从空闲货位中选择 K 个并确定分配顺序。

染色体编码：长度为 K 的整数数组，每个元素是一个空闲货位的ID，表示第 k 个托盘分配到哪个货位。商品到托盘的映射是固定的（按订单项顺序依次装托盘），只优化托盘到货位的映射。

```
染色体示例：[loc_5, loc_12, loc_3, loc_8, ...]
含义：第1个托盘放到货位5，第2个托盘放到货位12，第3个托盘放到货位3...
```

#### 3.5.2 适应度函数

```
fitness = 1 / (1 + 总存取距离)
总存取距离 = Σ T(chromosome[k])，k = 1..K
```

fitness 越大越好，总存取距离越小越好。

#### 3.5.3 算法参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 种群大小 | 50 | 每代50个个体 |
| 最大迭代数 | 100 | 最多迭代100代 |
| 交叉率 | 0.8 | 80%概率进行交叉 |
| 变异率 | 0.1 | 10%概率发生变异 |
| 选择方式 | 锦标赛选择 | 每次随机取3个，选最优 |

#### 3.5.4 遗传操作

**初始化**：从空闲货位中随机选取 K 个，随机排列，生成50个初始个体。

**选择**：锦标赛选择法，每次从种群中随机抽取3个个体，选fitness最高的进入下一代。

**交叉（OX顺序交叉）**：

```
parent1: [A, B, C, D, E, F]
parent2: [D, F, B, E, A, C]
随机选择交叉段 [2,4]（即位置2到4）

child1: 保留parent1的[2,4]段 → [_, _, C, D, E, _]
        从parent2中按顺序填入剩余 → [F, B, C, D, E, A]
```

**变异（交换变异）**：随机选取染色体中两个位置，交换其货位ID。

#### 3.5.5 算法主流程

```
1. 计算总托盘需求 K
2. 获取所有空闲货位列表 available[]
3. 初始化种群 population[50]，每个个体为 available 中随机选取K个的随机排列
4. for gen = 1 to 100:
   4.1 计算每个个体的 fitness
   4.2 记录当前最优个体 best
   4.3 通过锦标赛选择产生新种群
   4.4 对新种群两两进行OX交叉（概率0.8）
   4.5 对每个个体进行交换变异（概率0.1）
5. 返回全局最优个体 best 作为分配方案
6. 将 best 染色体解码为分配结果
```

#### 3.5.6 解码

```
1. 按入库订单项顺序，依次计算每个SKU需要几个托盘
   pallets[] = [ {sku: 手机, qty: 200, count: ceil(200/capacity_phone)}, ... ]
2. 展平为托盘序列 pallet_list = [手机托盘1, 手机托盘2, ..., 电脑托盘1, ...]
3. chromosome[k] 对应 pallet_list[k]，即第k个托盘放到chromosome[k]指定的货位
```

---

## 四、功能模块设计

### 4.1 基础数据管理

**仓库管理**：创建/编辑仓库信息，配置层数、列数、托盘容积、堆垛机速度参数。创建仓库时自动批量生成对应的货位记录（M层×N列）。

**商品管理**：维护SKU信息，包括名称、分类、单件体积、单件重量。

**货位管理**：查看所有货位状态，支持按层（Y）与侧（Z）筛选，手动锁定/解锁货位。

仓库里存放了货物的货位鼠标放上去可以显示货物信息

### 4.2 入库订单管理

**创建订单**：填写订单基本信息，添加多个订单项（选择SKU + 填写数量）。

**执行入库**：选择一个待处理的订单，选择分配策略（分类存储/就近原则/遗传算法），点击执行。后端调用对应算法生成分配结果，更新货位状态为占用，记录分配明细。

**订单详情**：查看某个已完成订单的分配结果列表，包括每个货位分配了什么商品、多少件、存取距离是多少。

**功能**：集中管理所有入库订单，支持新增订单和对已有订单进行操作。

**输出**：

- 订单 ID、订单号、状态（如`COMPLETED`/`CREATED`）、操作员、创建时间

- 操作按钮：管理入库（进入明细页）

  入库订单明细

  - **功能**：对单个入库订单进行明细管理，添加货物需求并调用智能算法分配货位。
  - **输出**：
    - 订单基本信息：订单号、状态、操作员
    - 入库货物明细：SKU 名称、需求数量、已分配数量、已分配货位
    - 分配结果：系统推荐的货位 ID 和分配数量
    - 操作按钮：提交分配（调用算法）、确认入库、返回订单列表

### 4.3 出库管理与明细

### 出库订单管理列表

- **功能**：集中管理所有出库订单，支持新增订单和对已有订单进行操作。

- **输出**：

  - 订单 ID、订单号、状态（如`COMPLETED`/`CREATED`）、操作员、创建时间
  - 操作按钮：管理出库（进入明细页）

  

------

###  出库订单明细

- **功能**：对单个出库订单进行明细管理，添加 / 编辑 / 删除出库货物。
- **输出**：
  - 订单基本信息：订单号、状态、操作员、创建时间
  - 出库明细表格：支持选择 SKU（如电脑、电视机、洗衣机、冰箱）、选择对应货位、填写出库数量
  - 操作按钮：添加明细、确认出库、返回订单列表

### 4.4 策略仿真对比

这是系统的核心展示模块。

**仿真入口**：选择一个入库订单（通常是待处理状态），点击"仿真对比"。系统会对该订单同时运行三种策略，每种策略独立计算分配方案，结果不会实际写入货位表（仿真不影响真实数据）。

**仿真结果展示**：

页面分为上下两部分。上半部分是三个并排的仓库可视化图，分别对应三种策略的分配结果。可视化以三维为主，支持按 Z 侧与 Y 层选择切片，切片视图为 X×Y 的二维矩阵，每个格子代表一个货位：

- 灰色 = 空闲
- 不同颜色按商品分类着色（如手机=蓝色，电脑=绿色，冰箱=橙色）
- 鼠标悬浮货位时，tooltip 显示：货位坐标 (x,y,z)、商品名称、存放件数、空间占用率、存取距离

下半部分是指标对比表格/图表：

| 指标 | 分类存储 | 就近原则 | 遗传算法 |
|------|---------|---------|---------|
| 总存取距离（秒） | - | - | - |
| 平均存取距离（秒/次） | - | - | - |
| 空间利用率（%） | - | - | - |
| 使用货位数 | - | - | - |
| 算法耗时（ms） | - | - | - |

配合柱状图直观对比。

### 4.5 仓库可视化看板

独立的仓库实时状态页面，展示当前仓库各货位的真实占用情况。支持按层（Y）与侧（Z）切换显示三维切片，鼠标悬浮查看货位详情。与仿真模块的区别是：这里展示的是真实数据，仿真模块展示的是模拟数据。

### 仓库总览界面

- **功能**：以网格形式直观展示仓库货位分布与占用情况，鼠标悬停可查看单个货位的详细信息。
- **输出**：
  - 货位 ID、所属区域、坐标位置
  - 存储的 SKU 名称、尺寸、出入库频率、当前库存数量
  - 不同颜色区分货位状态（如占用、空闲）

---

## 五、接口设计

### 5.1 仓库管理

```
POST   /api/warehouse          创建仓库（同时批量创建货位）
GET    /api/warehouse/{id}     获取仓库详情
PUT    /api/warehouse/{id}     更新仓库参数
GET    /api/warehouse/{id}/locations?y=1&z=0  获取货位列表（支持按层与侧筛选）
```

### 5.2 商品管理

```
POST   /api/sku                创建商品
GET    /api/sku                商品列表（支持分页、分类筛选）
PUT    /api/sku/{id}           更新商品信息
DELETE /api/sku/{id}           删除商品
```

### 5.3 入库订单

```
POST   /api/inbound-order                     创建入库订单（含订单项）
GET    /api/inbound-order                      订单列表
GET    /api/inbound-order/{id}                 订单详情（含订单项）
POST   /api/inbound-order/{id}/execute         执行入库（参数：strategyType）
GET    /api/inbound-order/{id}/allocation       查看分配结果
```

### 5.4 策略仿真

```
POST   /api/simulation/{orderId}/run           执行仿真（同时运行三种策略）
GET    /api/simulation/{orderId}/result         获取仿真结果（含三种策略的分配明细和指标）
```

### 5.5 仓库可视化

```
GET    /api/warehouse/{id}/visualization       获取仓库当前状态（所有货位及其占用信息）
```

---

## 六、前端页面设计

| 页面 | 路由 | 功能 |
|------|------|------|
| 仓库管理 | /warehouse | 仓库CRUD、参数配置 |
| 商品管理 | /sku | 商品SKU的增删改查 |
| 货位管理 | /locations | 按层查看货位状态，手动锁定/解锁 |
| 入库订单 | /inbound | 订单列表、创建订单、选择策略执行入库 |
| 订单详情 | /inbound/:id | 查看分配结果明细 |
| 策略仿真 | /simulation | 选择订单→运行仿真→三图+指标对比 |
| 仓库看板 | /dashboard | 实时仓库可视化（按层切换、悬浮查看详情） |

### 仿真页面布局

```
┌─────────────────────────────────────────────────────┐
│  选择入库订单: [下拉框]    [运行仿真]               │
├─────────────────┬─────────────────┬─────────────────┤
│   分类存储策略    │   就近原则策略   │   遗传算法策略    │
│  ┌─┬─┬─┬─┬─┐   │  ┌─┬─┬─┬─┬─┐   │  ┌─┬─┬─┬─┬─┐   │
│  ├─┼─┼─┼─┼─┤   │  ├─┼─┼─┼─┼─┤   │  ├─┼─┼─┼─┼─┤   │
│  ├─┼─┼─┼─┼─┤   │  ├─┼─┼─┼─┼─┤   │  ├─┼─┼─┼─┼─┤   │
│  ├─┼─┼─┼─┼─┤   │  ├─┼─┼─┼─┼─┤   │  ├─┼─┼─┼─┼─┤   │
│  └─┴─┴─┴─┴─┘   │  └─┴─┴─┴─┴─┘   │  └─┴─┴─┴─┴─┘   │
│  (悬浮显示详情)   │  (悬浮显示详情)  │  (悬浮显示详情)   │
├─────────────────┴─────────────────┴─────────────────┤
│                   指标对比                            │
│  ┌─────────────────────────────────────────────┐    │
│  │ 柱状图：总存取距离 / 空间利用率 / 算法耗时    │    │
│  └─────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────┐    │
│  │ 表格：各策略详细指标数值                      │    │
│  └─────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────┘
```

---

## 七、算法后端实现要点

### 7.1 策略接口抽象

```java
public interface AllocationStrategy {
    /**
     * 执行货位分配
     * @param warehouse 仓库信息（含堆垛机速度等参数）
     * @param items 入库订单项列表
     * @param availableLocations 当前空闲货位列表
     * @return 分配结果列表
     */
    AllocationResult allocate(Warehouse warehouse, 
                              List<InboundOrderItem> items,
                              List<StorageLocation> availableLocations);
}
```

三种策略分别实现该接口：`CategoryStrategy`、`NearestStrategy`、`GeneticStrategy`。

### 7.2 距离计算工具方法

```java
public static double calcAccessTime(StorageLocation loc, Warehouse wh) {
    double hTime = Math.abs(loc.getColNum() - wh.getEntryCol()) * wh.getHorizontalSpeed();
    double vTime = Math.abs(loc.getRowNum() - wh.getEntryRow()) * wh.getVerticalSpeed();
    return Math.max(hTime, vTime);
}
```

### 7.3 仿真服务

仿真不修改真实货位数据。执行流程为：获取当前空闲货位快照 → 分别调用三种策略的 allocate 方法 → 计算各项指标 → 存入 simulation_result 表 → 返回结果。

```java
public SimulationVO runSimulation(Long orderId) {
    List<InboundOrderItem> items = orderItemMapper.selectByOrderId(orderId);
    List<StorageLocation> freeLocations = locationMapper.selectFreeLocations(warehouseId);
    Warehouse wh = warehouseMapper.selectById(warehouseId);
    
    SimulationVO vo = new SimulationVO();
    for (String strategyType : Arrays.asList("CATEGORY", "NEAREST", "GENETIC")) {
        AllocationStrategy strategy = strategyFactory.get(strategyType);
        long start = System.currentTimeMillis();
        AllocationResult result = strategy.allocate(wh, items, new ArrayList<>(freeLocations));
        long elapsed = System.currentTimeMillis() - start;
        
        // 计算指标
        double totalDist = result.getDetails().stream()
            .mapToDouble(d -> calcAccessTime(d.getLocation(), wh)).sum();
        double spaceUtil = result.getDetails().stream()
            .mapToDouble(d -> d.getAllocatedVolume() / wh.getPalletVolume()).average().orElse(0) * 100;
        
        vo.addResult(strategyType, result, totalDist, spaceUtil, elapsed);
    }
    return vo;
}
```

---

## 八、数据流示意

### 8.1 正常入库流程

```
用户创建入库订单（含多个订单项）
    ↓
用户选择分配策略，点击"执行入库"
    ↓
后端调用对应策略的 allocate 方法
    ↓
生成分配结果，写入 allocation_result 表
    ↓
更新 storage_location 表（状态→占用，记录SKU和数量）
    ↓
更新订单状态为"已完成"
    ↓
前端刷新仓库看板，展示最新货位状态
```

### 8.2 策略仿真流程

```
用户选择一个入库订单，点击"运行仿真"
    ↓
后端获取当前空闲货位快照（不锁定、不修改）
    ↓
分别调用三种策略计算分配方案
    ↓
计算各策略指标（总距离、空间利用率、耗时）
    ↓
存入 simulation_result 表
    ↓
返回三组分配明细 + 指标数据
    ↓
前端渲染三个仓库网格图 + 指标对比图表
```
